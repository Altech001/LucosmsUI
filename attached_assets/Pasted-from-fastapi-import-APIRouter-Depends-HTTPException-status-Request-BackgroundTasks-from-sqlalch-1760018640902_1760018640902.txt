from fastapi import APIRouter, Depends, HTTPException, status, Request, BackgroundTasks
from sqlalchemy.orm import Session
from sqlalchemy import func, and_
from typing import List, Optional
from datetime import datetime

from database.maindb import get_db
from models.models import Users, Transactions, Messages, DeliveryReports, Contact, ContactGroup
from schemas.schema import (
    TopupRequest, TransactionResponse, UserResponse,
    SMSRequest, SMSResponse, BulkSMSRequest, BulkSMSResponse,
    MessageFilter
)
from routes.authclerk import get_current_user
from functions.sms import LucoSMS

sendsms = APIRouter(
    prefix="/api/v1/account",
    tags=["Client Account"]
)


# ============= Helper Functions =============

async def get_current_user_id(request: Request, db: Session = Depends(get_db)) -> str:
    """Get user_id from existing auth"""
    session = await get_current_user(request, db)
    # session_userid = "user_2xQ4wGyrwRavEZmeadP4vd5Sx8z"
    
    db_user = db.query(Users).filter(Users.clerk_user_id == session.userid).first()
    if not db_user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found in database"
        )
    
    return db_user.id


def get_user(db: Session, user_id: str) -> Users:
    """Get user object"""
    user = db.query(Users).filter(Users.id == user_id).first()
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    return user


def process_sms_sending(message_ids: List[int], db: Session):
    """Background task to send SMS via Africa's Talking"""
    try:
        sms_service = LucoSMS()
        
        messages = db.query(Messages).filter(Messages.id.in_(message_ids)).all()
        
        for message in messages:
            try:
                # Send via Africa's Talking
                response = sms_service.send_message(
                    message=message.message,
                    recipients=[message.recipient],
                    sender_id=message.sender_id
                )
                
                # Update message status based on response
                if response and response.get('SMSMessageData', {}).get('Recipients'):
                    recipient_data = response['SMSMessageData']['Recipients'][0]
                    message.status = recipient_data.get('status', 'sent')
                else:
                    message.status = "sent"
                    
            except Exception as e:
                message.status = "failed"
                print(f"Failed to send message {message.id}: {str(e)}")
        
        db.commit()
        
    except Exception as e:
        print(f"Background SMS processing error: {str(e)}")
        db.rollback()


# ============= WALLET ENDPOINTS =============

@sendsms.get("/wallet", response_model=UserResponse)
def get_wallet_balance(
    user_id: str = Depends(get_current_user_id),
    db: Session = Depends(get_db)
):
    """Get current wallet balance"""
    user = get_user(db, user_id)
    return user


@sendsms.post("/wallet/topup", response_model=TransactionResponse)
def topup_wallet(
    topup_data: TopupRequest,
    user_id: str = Depends(get_current_user_id),
    db: Session = Depends(get_db)
):
    """Add funds to wallet"""
    user = get_user(db, user_id)
    
    # Update wallet balance
    user.wallet_balance += topup_data.amount
    
    # Create transaction record
    transaction = Transactions(
        user_id=user_id,
        amount=topup_data.amount,
        transaction_type="topup"
    )
    
    db.add(transaction)
    db.commit()
    db.refresh(transaction)
    
    return transaction


@sendsms.get("/wallet/transactions", response_model=List[TransactionResponse])
def get_transactions(
    skip: int = 0,
    limit: int = 100,
    transaction_type: Optional[str] = None,
    user_id: str = Depends(get_current_user_id),
    db: Session = Depends(get_db)
):
    """Get transaction history"""
    query = db.query(Transactions).filter(Transactions.user_id == user_id)
    
    if transaction_type:
        query = query.filter(Transactions.transaction_type == transaction_type)
    
    transactions = query.order_by(Transactions.created_at.desc()).offset(skip).limit(limit).all()
    return transactions


# ============= SEND SMS ENDPOINTS =============